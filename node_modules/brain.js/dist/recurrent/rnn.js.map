{"version":3,"sources":["../../src/recurrent/rnn.js"],"names":["RNN","options","defaults","constructor","Object","assign","stepCache","runs","totalCost","ratioClipped","model","inputLookup","outputLookup","json","fromJSON","input","hiddenLayers","output","equations","allMatrices","equationConnections","outputConnector","dataFormatter","inputSize","inputRange","outputSize","characters","length","mapModel","push","getModel","prevSize","d","hiddenSize","weight","RandomMatrix","transition","bias","Matrix","equation","inputMatrix","previousResult","hiddenLayer","relu","bind","add","multiply","lastHiddenSize","Equation","outputs","equationConnection","initialLayerInputs","getEquation","inputMatrixToRow","i","max","map","size","createInputMatrix","Error","createHiddenLayers","hiddenMatrix","property","hasOwnProperty","createOutputMatrix","learningRate","error","runInput","runBackpropagate","step","log2ppl","cost","bindEquation","inputIndex","inputMax","equationIndex","source","target","run","logProbabilities","probabilities","Math","log2","weights","log","deltas","slice","pow","stepSize","regc","clipval","numClipped","numTot","matrixIndex","matrix","rows","columns","cache","r","w","decayRate","sqrt","smoothEps","rawInput","isSampleI","temperature","maxPredictionLength","specialIndexes","isRunnable","formatDataIn","previousIndex","outputMatrix","j","probs","nextIndex","formatDataOut","value","data","trainDefaults","iterations","errorThresh","console","logPeriod","callback","callbackPeriod","Infinity","setupData","initialize","sum","err","trainPattern","isNaN","p","type","name","toJSON","layers","JSON","stringify","hiddenSizes","forEach","DataFormatter","states","jsonString","matrixOrigin","m","stateIndex","state","previousConnectionIndex","left","right","product","connection","indexOf","matrixToString","toInner","fnString","toString","split","shift","join","pop","replace","fileName","fnName","toLowerCase","statesRaw","usedFunctionNames","innerFunctionsSwitch","forwardFn","src","toFunctionString","zeros","softmax","randomF","sampleI","maxI","Function","Array","isArray","values","result","fromArrayInputOutput","addUnrecognized","indexTable","toIndexesInputOutput","toIndexes","toCharacters","keepNetworkIntact"],"mappings":"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","file":"rnn.js","sourcesContent":["import Matrix from './matrix';\nimport RandomMatrix from './matrix/random-matrix';\nimport Equation from './matrix/equation';\nimport sampleI from './matrix/sample-i';\nimport maxI from './matrix/max-i';\nimport softmax from './matrix/softmax';\nimport copy from './matrix/copy';\nimport { randomF } from '../utilities/random';\nimport zeros from '../utilities/zeros';\nimport DataFormatter from '../utilities/data-formatter';\n\nexport default class RNN {\n  constructor(options = {}) {\n    const defaults = this.constructor.defaults;\n\n    Object.assign(this, defaults, options);\n\n    this.stepCache = {};\n    this.runs = 0;\n    this.totalCost = null;\n    this.ratioClipped = null;\n    this.model = null;\n\n    this.inputLookup = null;\n    this.outputLookup = null;\n\n    if (options.json) {\n      this.fromJSON(options.json);\n    }\n  }\n\n  initialize() {\n    this.model = {\n      input: null,\n      hiddenLayers: [],\n      output: null,\n      equations: [],\n      allMatrices: [],\n      equationConnections: [],\n      outputConnector: null,\n    };\n\n    if (this.dataFormatter !== null) {\n      this.inputSize =\n      this.inputRange =\n      this.outputSize = this.dataFormatter.characters.length;\n    }\n    this.mapModel();\n  }\n\n  createHiddenLayers() {\n    //0 is end, so add 1 to offset\n    this.model.hiddenLayers.push(this.getModel(this.hiddenLayers[0], this.inputSize));\n    let prevSize = this.hiddenLayers[0];\n\n    for (let d = 1; d < this.hiddenLayers.length; d++) { // loop over depths\n      let hiddenSize = this.hiddenLayers[d];\n      this.model.hiddenLayers.push(this.getModel(hiddenSize, prevSize));\n      prevSize = hiddenSize;\n    }\n  }\n\n  /**\n   *\n   * @param {Number} hiddenSize\n   * @param {Number} prevSize\n   * @returns {object}\n   */\n  getModel(hiddenSize, prevSize) {\n    return {\n      //wxh\n      weight: new RandomMatrix(hiddenSize, prevSize, 0.08),\n      //whh\n      transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),\n      //bhh\n      bias: new Matrix(hiddenSize, 1)\n    };\n  }\n\n  /**\n   *\n   * @param {Equation} equation\n   * @param {Matrix} inputMatrix\n   * @param {Matrix} previousResult\n   * @param {Object} hiddenLayer\n   * @returns {Matrix}\n   */\n  getEquation(equation, inputMatrix, previousResult, hiddenLayer) {\n    let relu = equation.relu.bind(equation);\n    let add = equation.add.bind(equation);\n    let multiply = equation.multiply.bind(equation);\n\n    return relu(\n      add(\n        add(\n          multiply(\n            hiddenLayer.weight,\n            inputMatrix\n          ),\n          multiply(\n            hiddenLayer.transition,\n            previousResult\n          )\n        ),\n        hiddenLayer.bias\n      )\n    );\n  }\n\n  createInputMatrix() {\n    //0 is end, so add 1 to offset\n    this.model.input = new RandomMatrix(this.inputRange + 1, this.inputSize, 0.08);\n  }\n\n  createOutputMatrix() {\n    let model = this.model;\n    let outputSize = this.outputSize;\n    let lastHiddenSize = this.hiddenLayers[this.hiddenLayers.length - 1];\n\n    //0 is end, so add 1 to offset\n    //whd\n    model.outputConnector = new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08);\n    //0 is end, so add 1 to offset\n    //bd\n    model.output = new Matrix(outputSize + 1, 1);\n  }\n\n  bindEquation() {\n    let model = this.model;\n    let equation = new Equation();\n    let outputs = [];\n    let equationConnection = model.equationConnections.length > 0\n      ? model.equationConnections[model.equationConnections.length - 1]\n      : this.initialLayerInputs\n      ;\n\n      // 0 index\n    let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], model.hiddenLayers[0]);\n    outputs.push(output);\n    // 1+ indices\n    for (let i = 1, max = this.hiddenLayers.length; i < max; i++) {\n      output = this.getEquation(equation, output, equationConnection[i], model.hiddenLayers[i]);\n      outputs.push(output);\n    }\n\n    model.equationConnections.push(outputs);\n    equation.add(equation.multiply(model.outputConnector, output), model.output);\n    model.equations.push(equation);\n  }\n\n  mapModel() {\n    let model = this.model;\n    let hiddenLayers = model.hiddenLayers;\n    let allMatrices = model.allMatrices;\n    this.initialLayerInputs = this.hiddenLayers.map((size) => new Matrix(size, 1));\n\n    this.createInputMatrix();\n    if (!model.input) throw new Error('net.model.input not set');\n    allMatrices.push(model.input);\n\n    this.createHiddenLayers();\n    if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');\n    for (let i = 0, max = hiddenLayers.length; i < max; i++) {\n      let hiddenMatrix = hiddenLayers[i];\n      for (let property in hiddenMatrix) {\n        if (!hiddenMatrix.hasOwnProperty(property)) continue;\n        allMatrices.push(hiddenMatrix[property]);\n      }\n    }\n\n    this.createOutputMatrix();\n    if (!model.outputConnector) throw new Error('net.model.outputConnector not set');\n    if (!model.output) throw new Error('net.model.output not set');\n\n    allMatrices.push(model.outputConnector);\n    allMatrices.push(model.output);\n  }\n\n  /**\n   *\n   * @param {Number[]} input\n   * @param {Number} [learningRate]\n   * @returns {number}\n   */\n  trainPattern(input, learningRate = null) {\n    const error = this.runInput(input);\n    this.runBackpropagate(input);\n    this.step(learningRate);\n    return error;\n  }\n\n  /**\n   *\n   * @param {Number[]} input\n   * @returns {number}\n   */\n  runInput(input) {\n    this.runs++;\n    let model = this.model;\n    let max = input.length;\n    let log2ppl = 0;\n    let cost = 0;\n    let equation;\n    while (model.equations.length <= input.length + 1) {//last is zero\n      this.bindEquation();\n    }\n    for (let inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {\n      // start and end tokens are zeros\n      let equationIndex = inputIndex + 1;\n      equation = model.equations[equationIndex];\n\n      let source = (inputIndex === -1 ? 0 : input[inputIndex] + 1); // first step: start with START token\n      let target = (inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1); // last step: end with END token\n      let output = equation.run(source);\n      // set gradients into log probabilities\n      let logProbabilities = output; // interpret output as log probabilities\n      let probabilities = softmax(output); // compute the softmax probabilities\n\n      log2ppl += -Math.log2(probabilities.weights[target]); // accumulate base 2 log prob and do smoothing\n      cost += -Math.log(probabilities.weights[target]);\n      // write gradients into log probabilities\n      logProbabilities.deltas = probabilities.weights.slice(0);\n      logProbabilities.deltas[target] -= 1;\n    }\n\n    this.totalCost = cost;\n    return Math.pow(2, log2ppl / (max - 1)) / 100;\n  }\n\n  /**\n   * @param {Number[]} input\n   */\n  runBackpropagate(input) {\n    let i = input.length;\n    let model = this.model;\n    let equations = model.equations;\n    while(i > 0) {\n      equations[i].runBackpropagate(input[i - 1] + 1);\n      i--;\n    }\n    equations[0].runBackpropagate(0);\n  }\n\n  /**\n   *\n   * @param {Number} [learningRate]\n   */\n  step(learningRate = null) {\n    // perform parameter update\n    //TODO: still not sure if this is ready for learningRate\n    let stepSize = this.learningRate;\n    let regc = this.regc;\n    let clipval = this.clipval;\n    let model = this.model;\n    let numClipped = 0;\n    let numTot = 0;\n    let allMatrices = model.allMatrices;\n    for (let matrixIndex = 0; matrixIndex < allMatrices.length; matrixIndex++) {\n      const matrix = allMatrices[matrixIndex];\n      const { weights, deltas }  = matrix;\n      if (!(matrixIndex in this.stepCache)) {\n        this.stepCache[matrixIndex] = zeros(matrix.rows * matrix.columns);\n      }\n      const cache = this.stepCache[matrixIndex];\n      for (let i = 0; i < weights.length; i++) {\n        let r = deltas[i];\n        let w = weights[i];\n        // rmsprop adaptive learning rate\n        cache[i] = cache[i] * this.decayRate + (1 - this.decayRate) * r * r;\n        // gradient clip\n        if (r > clipval) {\n          r = clipval;\n          numClipped++;\n        }\n        if (r < -clipval) {\n          r = -clipval;\n          numClipped++;\n        }\n        numTot++;\n        // update (and regularize)\n        weights[i] = w + -stepSize * r / Math.sqrt(cache[i] + this.smoothEps) - regc * w;\n      }\n    }\n    this.ratioClipped = numClipped / numTot;\n  }\n\n\n  /**\n   *\n   * @returns boolean\n   */\n  get isRunnable(){\n    if(this.model.equations.length === 0){\n      console.error(`No equations bound, did you run train()?`);\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   *\n   * @param {Number[]|*} [rawInput]\n   * @param {Boolean} [isSampleI]\n   * @param {Number} temperature\n   * @returns {*}\n   */\n  run(rawInput = [], isSampleI = false, temperature = 1) {\n    const maxPredictionLength = this.maxPredictionLength + rawInput.length + (this.dataFormatter ? this.dataFormatter.specialIndexes.length : 0);\n    if (!this.isRunnable) return null;\n    const input = this.formatDataIn(rawInput);\n    const model = this.model;\n    const output = [];\n    let i = 0;\n    while (true) {\n      let previousIndex = (i === 0\n        ? 0\n        : i < input.length\n          ? input[i - 1] + 1\n          : output[i - 1])\n          ;\n      while (model.equations.length <= i) {\n        this.bindEquation();\n      }\n      let equation = model.equations[i];\n      // sample predicted letter\n      let outputMatrix = equation.run(previousIndex);\n      let logProbabilities = new Matrix(model.output.rows, model.output.columns);\n      copy(logProbabilities, outputMatrix);\n      if (temperature !== 1 && isSampleI) {\n        /**\n         * scale log probabilities by temperature and re-normalize\n         * if temperature is high, logProbabilities will go towards zero\n         * and the softmax outputs will be more diffuse. if temperature is\n         * very low, the softmax outputs will be more peaky\n         */\n        for (let j = 0, max = logProbabilities.weights.length; j < max; j++) {\n          logProbabilities.weights[j] /= temperature;\n        }\n      }\n\n      let probs = softmax(logProbabilities);\n      let nextIndex = (isSampleI ? sampleI(probs) : maxI(probs));\n\n      i++;\n      if (nextIndex === 0) {\n        // END token predicted, break out\n        break;\n      }\n      if (i >= maxPredictionLength) {\n        // something is wrong\n        break;\n      }\n\n      output.push(nextIndex);\n    }\n\n    /**\n     * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the\n     * network what is contained in input, so the data is essentially guessed by the network what could be next, till it\n     * locks in on a value.\n     * Kind of like this, values are from input:\n     * 0 -> 4 (or in English: \"beginning on input\" -> \"I have no idea? I'll guess what they want next!\")\n     * 2 -> 2 (oh how interesting, I've narrowed down values...)\n     * 1 -> 9 (oh how interesting, I've now know what the values are...)\n     * then the output looks like: [4, 2, 9,...]\n     * so we then remove the erroneous data to get our true output\n     */\n    return this.formatDataOut(\n      input,\n      output\n        .slice(input.length)\n        .map(value => value - 1)\n    );\n  }\n\n  /**\n   *\n   * @param {Object[]|String[]} data an array of objects: `{input: 'string', output: 'string'}` or an array of strings\n   * @param {Object} [options]\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, options = {}) {\n    options = Object.assign({}, this.constructor.trainDefaults, options);\n    let iterations = options.iterations;\n    let errorThresh = options.errorThresh;\n    let log = options.log === true ? console.log : options.log;\n    let logPeriod = options.logPeriod;\n    let learningRate = options.learningRate || this.learningRate;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod;\n    let error = Infinity;\n    let i;\n\n    if (this.hasOwnProperty('setupData')) {\n      data = this.setupData(data);\n    }\n\n    if (!this.model) {\n      this.initialize();\n    }\n\n    for (i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j], learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');\n      if (log && (i % logPeriod === 0)) {\n        log(`iterations: ${ i }, training error: ${ error }`);\n      }\n      if (callback && (i % callbackPeriod === 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @returns {Object}\n   */\n  toJSON() {\n    const defaults = this.constructor.defaults;\n    if (!this.model) {\n      this.initialize();\n    }\n    let model = this.model;\n    let options = {};\n    for (let p in defaults) {\n      if (defaults.hasOwnProperty(p)) {\n        options[p] = this[p];\n      }\n    }\n\n    return {\n      type: this.constructor.name,\n      options: options,\n      input: model.input.toJSON(),\n      hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {\n        let layers = {};\n        for (let p in hiddenLayer) {\n          layers[p] = hiddenLayer[p].toJSON();\n        }\n        return layers;\n      }),\n      outputConnector: this.model.outputConnector.toJSON(),\n      output: this.model.output.toJSON()\n    };\n  }\n\n  toJSONString() {\n    return JSON.stringify(this.toJSON());\n  }\n\n  fromJSON(json) {\n    const defaults = this.constructor.defaults;\n    const options = json.options;\n    this.model = null;\n    this.hiddenLayers = null;\n    const allMatrices = [];\n    const input = Matrix.fromJSON(json.input);\n    allMatrices.push(input);\n    const hiddenLayers = [];\n\n    // backward compatibility for hiddenSizes\n    (json.hiddenLayers || json.hiddenSizes).forEach((hiddenLayer) => {\n      let layers = {};\n      for (let p in hiddenLayer) {\n        layers[p] = Matrix.fromJSON(hiddenLayer[p]);\n        allMatrices.push(layers[p]);\n      }\n      hiddenLayers.push(layers);\n    });\n\n    const outputConnector = Matrix.fromJSON(json.outputConnector);\n    allMatrices.push(outputConnector);\n    const output = Matrix.fromJSON(json.output);\n    allMatrices.push(output);\n\n    Object.assign(this, defaults, options);\n\n    // backward compatibility\n    if (options.hiddenSizes) {\n      this.hiddenLayers = options.hiddenSizes;\n    }\n\n    if (options.hasOwnProperty('dataFormatter') && options.dataFormatter !== null) {\n      this.dataFormatter = DataFormatter.fromJSON(options.dataFormatter);\n    }\n\n    this.model = {\n      input,\n      hiddenLayers,\n      output,\n      allMatrices,\n      outputConnector,\n      equations: [],\n      equationConnections: [],\n    };\n    this.initialLayerInputs = this.hiddenLayers.map((size) => new Matrix(size, 1));\n    this.bindEquation();\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    let model = this.model;\n    let equations = this.model.equations;\n    let equation = equations[1];\n    let states = equation.states;\n    let jsonString = JSON.stringify(this.toJSON());\n\n    function matrixOrigin(m, stateIndex) {\n      for (let i = 0, max = states.length; i < max; i++) {\n        let state = states[i];\n\n        if (i === stateIndex) {\n          let j = previousConnectionIndex(m);\n          switch (m) {\n            case state.left:\n              if (j > -1) {\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\n              }\n            case state.right:\n              if (j > -1) {\n                return `typeof prevStates[${ j }] === 'object' ? prevStates[${ j }].product : new Matrix(${ m.rows }, ${ m.columns })`;\n              }\n            case state.product:\n              return `new Matrix(${ m.rows }, ${ m.columns })`;\n            default:\n              throw Error('unknown state');\n          }\n        }\n\n        if (m === state.product) return `states[${ i }].product`;\n        if (m === state.right) return `states[${ i }].right`;\n        if (m === state.left) return `states[${ i }].left`;\n      }\n    }\n\n    function previousConnectionIndex(m) {\n      const connection = model.equationConnections[0];\n      const states = equations[0].states;\n      for (let i = 0, max = states.length; i < max; i++) {\n        if (states[i].product === m) {\n          return i;\n        }\n      }\n      return connection.indexOf(m);\n    }\n\n    function matrixToString(m, stateIndex) {\n      if (!m || !m.rows || !m.columns) return 'null';\n\n      if (m === model.input) return `json.input`;\n      if (m === model.outputConnector) return `json.outputConnector`;\n      if (m === model.output) return `json.output`;\n\n      for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {\n        let hiddenLayer = model.hiddenLayers[i];\n        for (let p in hiddenLayer) {\n          if (!hiddenLayer.hasOwnProperty(p)) continue;\n          if (hiddenLayer[p] !== m) continue;\n          return `json.hiddenLayers[${ i }].${ p }`;\n        }\n      }\n\n      return matrixOrigin(m, stateIndex);\n    }\n\n    function toInner(fnString) {\n      // crude, but should be sufficient for now\n      // function() { body }\n      fnString = fnString.toString().split('{');\n      fnString.shift();\n      // body }\n      fnString = fnString.join('{');\n      fnString = fnString.split('}');\n      fnString.pop();\n      // body\n      return fnString.join('}').split('\\n').join('\\n        ')\n        .replace('product.deltas[i] = 0;', '')\n        .replace('product.deltas[column] = 0;', '')\n        .replace('left.deltas[leftIndex] = 0;', '')\n        .replace('right.deltas[rightIndex] = 0;', '')\n        .replace('product.deltas = left.deltas.slice(0);', '');\n    }\n\n    function fileName(fnName) {\n      return `src/recurrent/matrix/${ fnName.replace(/[A-Z]/g, function(value) { return '-' + value.toLowerCase(); }) }.js`;\n    }\n\n    let statesRaw = [];\n    let usedFunctionNames = {};\n    let innerFunctionsSwitch = [];\n    for (let i = 0, max = states.length; i < max; i++) {\n      let state = states[i];\n      statesRaw.push(`states[${ i }] = {\n      name: '${ state.forwardFn.name }',\n      left: ${ matrixToString(state.left, i) },\n      right: ${ matrixToString(state.right, i) },\n      product: ${ matrixToString(state.product, i) }\n    }`);\n\n      let fnName = state.forwardFn.name;\n      if (!usedFunctionNames[fnName]) {\n        usedFunctionNames[fnName] = true;\n        innerFunctionsSwitch.push(\n          `        case '${ fnName }': //compiled from ${ fileName(fnName) }\n          ${ toInner(state.forwardFn.toString()) }\n          break;`\n        );\n      }\n    }\n\n    const src = `\n  if (typeof rawInput === 'undefined') rawInput = [];\n  if (typeof isSampleI === 'undefined') isSampleI = false;\n  if (typeof temperature === 'undefined') temperature = 1;\n  ${ (this.dataFormatter !== null) ? this.dataFormatter.toFunctionString() : '' }\n  \n  var input = ${\n      (this.dataFormatter !== null && typeof this.formatDataIn === 'function')\n        ? 'formatDataIn(rawInput)' \n        : 'rawInput'\n    };\n  var json = ${ jsonString };\n  var maxPredictionLength = input.length + ${ this.maxPredictionLength };\n  var _i = 0;\n  var output = [];\n  var states = [];\n  var prevStates;\n  while (true) {\n    var previousIndex = (_i === 0\n        ? 0\n        : _i < input.length\n          ? input[_i - 1] + 1\n          : output[_i - 1])\n          ;\n    var rowPluckIndex = previousIndex;\n    var state;\n    prevStates = states;\n    states = [];\n    ${ statesRaw.join(';\\n    ') };\n    for (var stateIndex = 0, stateMax = ${ statesRaw.length }; stateIndex < stateMax; stateIndex++) {\n      state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n      \n      switch (state.name) {\n${ innerFunctionsSwitch.join('\\n') }\n      }\n    }\n    \n    var logProbabilities = state.product;\n    if (temperature !== 1 && isSampleI) {\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n        logProbabilities.weights[q] /= temperature;\n      }\n    }\n\n    var probs = softmax(logProbabilities);\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\n    \n    _i++;\n    if (nextIndex === 0) {\n      break;\n    }\n    if (_i >= maxPredictionLength) {\n      break;\n    }\n\n    output.push(nextIndex);\n  }\n  ${ (this.dataFormatter !== null && typeof this.formatDataOut === 'function') \n      ? 'return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))'\n      : 'return output.slice(input.length).map(function(value) { return value - 1; })' };\n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n  }\n  ${ this.dataFormatter !== null && typeof this.formatDataIn === 'function'\n      ? `function formatDataIn(input, output) { ${\n          toInner(this.formatDataIn.toString())\n            .replace(/this[.]dataFormatter[\\n\\s]+[.]/g, '')\n            .replace(/this[.]dataFormatter[.]/g, '')\n            .replace(/this[.]dataFormatter/g, 'true')\n        } }`\n      : '' }\n  ${ this.dataFormatter !== null && typeof this.formatDataOut === 'function'\n        ? `function formatDataOut(input, output) { ${\n            toInner(this.formatDataOut.toString())\n              .replace(/this[.]dataFormatter[\\n\\s]+[.]/g, '')\n              .replace(/this[.]dataFormatter[.]/g, '')\n              .replace(/this[.]dataFormatter/g, 'true')\n          } }` \n        : '' }\n  ${ zeros.toString() }\n  ${ softmax.toString().replace('_2.default', 'Matrix') }\n  ${ randomF.toString() }\n  ${ sampleI.toString() }\n  ${ maxI.toString() }`;\n    return new Function('rawInput', 'isSampleI', 'temperature', src);\n  }\n}\n\nRNN.defaults = {\n  inputSize: 20,\n  inputRange: 20,\n  hiddenLayers: [20,20],\n  outputSize: 20,\n  learningRate: 0.01,\n  decayRate: 0.999,\n  smoothEps: 1e-8,\n  regc: 0.000001,\n  clipval: 5,\n  maxPredictionLength: 100,\n  /**\n   *\n   * @param {*[]} data\n   * @returns {Number[]}\n   */\n  setupData: function(data) {\n    if (\n      typeof data[0] !== 'string'\n      && !Array.isArray(data[0])\n      && (\n        !data[0].hasOwnProperty('input')\n        || !data[0].hasOwnProperty('output')\n      )\n    ) {\n      return data;\n    }\n    let values = [];\n    const result = [];\n    if (typeof data[0] === 'string' || Array.isArray(data[0])) {\n      if (this.dataFormatter === null) {\n        for (let i = 0; i < data.length; i++) {\n          values.push(data[i]);\n        }\n        this.dataFormatter = new DataFormatter(values);\n      }\n      for (let i = 0, max = data.length; i < max; i++) {\n        result.push(this.formatDataIn(data[i]));\n      }\n    } else {\n      if (this.dataFormatter === null) {\n        for (let i = 0; i < data.length; i++) {\n          values.push(data[i].input);\n          values.push(data[i].output);\n        }\n        this.dataFormatter = DataFormatter.fromArrayInputOutput(values);\n        this.dataFormatter.addUnrecognized();\n      }\n      for (let i = 0, max = data.length; i < max; i++) {\n        result.push(this.formatDataIn(data[i].input, data[i].output));\n      }\n    }\n    return result;\n  },\n  /**\n   *\n   * @param {*[]} input\n   * @param {*[]} output\n   * @returns {Number[]}\n   */\n  formatDataIn: function(input, output = null) {\n    if (this.dataFormatter !== null) {\n      if (this.dataFormatter.indexTable.hasOwnProperty('stop-input')) {\n        return this.dataFormatter.toIndexesInputOutput(input, output);\n      } else {\n        return this.dataFormatter.toIndexes(input);\n      }\n    }\n    return input;\n  },\n  /**\n   *\n   * @param {Number[]} input\n   * @param {Number[]} output\n   * @returns {*}\n   */\n  formatDataOut: function(input, output) {\n    if (this.dataFormatter !== null) {\n      return this.dataFormatter\n        .toCharacters(output)\n        .join('');\n    }\n    return output;\n  },\n  dataFormatter: null\n};\n\nRNN.trainDefaults = {\n  iterations: 20000,\n  errorThresh: 0.005,\n  log: false,\n  logPeriod: 10,\n  learningRate: 0.3,\n  callback: null,\n  callbackPeriod: 10,\n  keepNetworkIntact: false\n};\n"]}