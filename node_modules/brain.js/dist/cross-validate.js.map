{"version":3,"sources":["../src/cross-validate.js"],"names":["CrossValidate","Classifier","options","json","trainOpts","trainSet","testSet","classifier","beginTrain","Date","now","trainingStats","train","beginTest","testStats","test","endTest","stats","Object","assign","trainTime","testTime","iterations","trainError","error","learningRate","hiddenLayers","network","toJSON","array","i","length","j","Math","floor","random","temp","data","k","Error","size","constructor","Array","shuffleArray","newData","keys","forEach","key","avgs","truePos","trueNeg","falsePos","falseNeg","total","results","stat","sum","dclone","slice","splice","result","testPartition","push","precision","recall","accuracy","testSize","trainSize","sets","fromJSON","crossValidateJson","reduce","prev","cur","Infinity","instance"],"mappings":"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","file":"cross-validate.js","sourcesContent":["export default class CrossValidate {\n\n  /**\n   *\n   * @param {NeuralNetwork|constructor} Classifier\n   * @param {object} [options]\n   */\n  constructor(Classifier, options) {\n    this.Classifier = Classifier;\n    this.options = options;\n    this.json = null;\n  }\n\n  /**\n   *\n   * @param {object} trainOpts\n   * @param {object} trainSet\n   * @param {object} testSet\n   * @returns {void|*}\n   */\n  testPartition(trainOpts, trainSet, testSet) {\n    let classifier = new this.Classifier(this.options);\n    let beginTrain = Date.now();\n    let trainingStats = classifier.train(trainSet, trainOpts);\n    let beginTest = Date.now();\n    let testStats = classifier.test(testSet);\n    let endTest = Date.now();\n    let stats = Object.assign({}, testStats, {\n      trainTime: beginTest - beginTrain,\n      testTime: endTest - beginTest,\n      iterations: trainingStats.iterations,\n      trainError: trainingStats.error,\n      learningRate: trainOpts.learningRate,\n      hiddenLayers: classifier.hiddenLayers,\n      network: classifier.toJSON()\n    });\n\n    return stats;\n  }\n\n  /**\n   * Randomize array element order in-place.\n   * Using Durstenfeld shuffle algorithm.\n   * source: http://stackoverflow.com/a/12646864/1324039\n   */\n  shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n      let j = Math.floor(Math.random() * (i + 1));\n      let temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n    }\n    return array;\n  }\n\n  /**\n   *\n   * @param {object} data\n   * @param {object} trainOpts\n   * @param {number} [k]\n   * @returns {\n   *  {\n   *    avgs: {\n   *      error: number,\n   *      trainTime: number,\n   *      testTime: number,\n   *      iterations: number,\n   *      trainError: number\n   *    },\n   *    stats: {\n   *      truePos: number,\n   *      trueNeg: number,\n   *      falsePos: number,\n   *      falseNeg: number,\n   *      total: number\n   *    },\n   *    sets: Array\n   *  }\n   * }\n   */\n  train(data, trainOpts = {}, k = 4) {\n    if (data.length <= k) {\n      throw new Error(`Training set size is too small for ${ data.length } k folds of ${ k }`);\n    }\n    let size = data.length / k;\n\n    if (data.constructor === Array) {\n      this.shuffleArray(data);\n    } else {\n      let newData = {};\n      this.shuffleArray(Object.keys(data)).forEach((key) => {\n        newData[key] = data[key];\n      });\n      data = newData;\n    }\n\n    let avgs = {\n      error: 0,\n      trainTime: 0,\n      testTime: 0,\n      iterations: 0,\n      trainError: 0\n    };\n\n    let stats = {\n      truePos: 0,\n      trueNeg: 0,\n      falsePos: 0,\n      falseNeg: 0,\n      total: 0\n    };\n\n    let results = [];\n    let stat;\n    let sum;\n\n    for (let i = 0; i < k; i++) {\n      let dclone = data.slice(0);\n      let testSet = dclone.splice(i * size, size);\n      let trainSet = dclone;\n      let result = this.testPartition(trainOpts, trainSet, testSet);\n      for (stat in avgs) {\n        if (stat in avgs) {\n          sum = avgs[stat];\n          avgs[stat] = sum + result[stat];\n        }\n      }\n\n      for (stat in stats) {\n        if (stat in stats) {\n          sum = stats[stat];\n          stats[stat] = sum + result[stat];\n        }\n      }\n\n      results.push(result);\n    }\n\n    for (stat in avgs) {\n      if (stat in avgs) {\n        sum = avgs[stat];\n        avgs[stat] = sum / k;\n      }\n    }\n\n    stats.precision = stats.truePos / (stats.truePos + stats.falsePos);\n    stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);\n    stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;\n\n    stats.testSize = size;\n    stats.trainSize = data.length - size;\n\n\n    this.json = {\n      avgs: avgs,\n      stats: stats,\n      sets: results\n    };\n  }\n\n  toNeuralNetwork() {\n    return this.fromJSON(this.json);\n  }\n\n  toJSON() {\n    return this.json;\n  }\n\n  fromJSON(crossValidateJson) {\n    const Classifier = this.Classifier;\n    const json = crossValidateJson.sets.reduce((prev, cur) => prev.error < cur.error ? prev : cur, {error: Infinity}).network;\n    if (Classifier.fromJSON) {\n      return Classifier.fromJSON(json);\n    }\n    const instance = new Classifier();\n    instance.fromJSON(json);\n    return instance;\n  }\n}\n"]}